/* Class implementing Big Integer Arithmetic operations 
@author Ravindhar Reddy Thallapureddy 
Last modified on: 5/11/2016 2:34pm */
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ArithmeticOperations {

	/**
	 * Returns a LongNumber after adding LongNumber l1 and LongNumber l2
	 * 
	 * @param l1
	 *            : LongNumber : input long number 1
	 * @param l2
	 *            : LongNumber : input long number 2
	 * @return : LongNumber : addition of l1 and l2
	 */
	static LongNumber add(LongNumber l1, LongNumber l2) {
		if(l1 == null || l2 == null)
			return null;
		long b1 = l1.base;
		long b2 = l2.base;
		if (b1 != b2)
			return null;
		return add(l1, l2, b1);
	}

	/**
	 * Returns a LongNumber after multiplying LongNumber l1 and LongNumber l2
	 * 
	 * @param l1
	 *            : LongNumber : input long number 1
	 * @param l2
	 *            : LongNumber : input long number 2
	 * @return : LongNumber : multiplication of l1 and l2
	 */
	static LongNumber product(LongNumber l1, LongNumber l2) {
		if(l1 == null || l2 == null)
			return null;
		long b1 = l1.base;
		long b2 = l2.base;
		if (b1 != b2)
			return null;
		boolean isResNeg = false;
		if((l1.isNegative || l2.isNegative) && !(l1.isNegative && l2.isNegative))
			isResNeg = true;
		List<Long> resultList;
		resultList = Product
				.product(l1.convertedNumber, l2.convertedNumber, b1);
		if(resultList == null)
			throw new ArithmeticException("One of the operand has no number, cannot perform multiplication.");
		LongNumber result = new LongNumber(resultList, b1, isResNeg);
		return result;
	}

	/**
	 * Returns a LongNumber after subtracting LongNumber l1 and LongNumber l2
	 * 
	 * @param l1
	 *            : LongNumber : input long number 1
	 * @param l2
	 *            : LongNumber : input long number 2
	 * @return : LongNumber : subtraction of l1 and l2
	 */
	static LongNumber subtract(LongNumber l1, LongNumber l2) {
		if(l1 == null || l2 == null)
			return null;
		long b1 = l1.base;
		long b2 = l2.base;
		if (b1 != b2)
			return null;
		return subtract(l1,l2, b1);
	}

	/**
	 * Returns a LongNumber which is a power of l1 to n.
	 * 
	 * @param l1
	 *            : LongNumber : input long number 1
	 * @param n
	 *            : long : represents the power
	 * @return : LongNumber : power of l1 to n.
	 */
	static LongNumber power(LongNumber l1, long n) {
		long b1 = l1.base;
		boolean isResNeg = false;
		List<Long> resultList = power(l1.convertedNumber, n, b1);
		if(n % 2 != 0 && l1.isNegative)
			isResNeg = true;
		LongNumber result = new LongNumber(resultList, b1, isResNeg);
		return result;
	}

	/**
	 * Populates the list z as an arithmetic addition of elements from x and y;
	 * each list represents a big integer which is stored in LSB to MSB (i.e.
	 * LSB at head).
	 * 
	 * @param x
	 *            : List<Long> : input list of integers to the base b
	 * @param y
	 *            : List<Long> : input list 2 of integers to the base b
	 * @param z
	 *            : List<Long> : output list after adding elements from x and y
	 * @param b
	 *            : long : lists contains Long to the base b
	 */
	public static void add(List<Long> x, List<Long> y, List<Long> z, long b) {
		Iterator<Long> xIterator = x.iterator();
		Iterator<Long> yIterator = y.iterator();

		Long xVal = Helper.next(xIterator);
		Long yVal = Helper.next(yIterator);

		long carry = 0;
		long sum = 0;

		// Invariant: carry is to hold any carry if generated by addition, sum
		// is to store the sum of elements; Iterates through both lists, adding
		// the elements (checking for carry), and appropriately updates z.
		while (xVal != null || yVal != null) {
			sum = carry;
			if (xVal != null) {
				sum = sum + xVal;
				xVal = Helper.next(xIterator);
			}
			if (yVal != null) {
				sum = sum + yVal;
				yVal = Helper.next(yIterator);
			}
			carry = sum / b;
			z.add(new Long(sum % b));
		}

		// if the addition has generated an element which is more than the size
		// of input lists e.g. 978 + 978 = 1956
		if (carry != 0)
			z.add(new Long(carry));
	}

	/**
	 * Updates y after adding x to it, note the value will be added from
	 * position 'shift' in x, if y is shorter in length 0's are appended. This
	 * is specifically used in cases like 12x10^6 + 24.
	 * 
	 * @param x
	 *            : List<Long> : input long number 1
	 * @param y
	 *            : List<Long> : input long number 2
	 * @param shift
	 *            : int : no of positions to shift
	 * @param toBase
	 *            : long : numbers are in base toBase
	 */
	public static void shiftAdd(List<Long> x, List<Long> y, int shift,
			long toBase) {
		int ySize = y.size();
		int xSize = x.size();
		int diff;
		if (shift >= ySize) {
			diff = shift - ySize;
			while (diff > 0) {
				y.add(new Long(0));
				diff--;
			}
			y.addAll(x);
		} else {
			int i;
			long sum, carry = 0;
			long xVal;
			for (i = 0; i < ySize - shift; i++) {
				sum = carry;
				long yVal = y.get(shift + i);
				if (i < xSize)
					xVal = x.get(i);
				else
					xVal = 0;
				sum = sum + xVal + yVal;
				carry = sum / toBase;
				y.set(shift + i, sum % toBase);
			}
			while (i < xSize) {
				sum = carry + x.get(i);
				y.add(new Long(sum % toBase));
				carry = sum / toBase;
				i++;
			}
			if (carry != 0)
				y.add(new Long(carry));
		}
	}

	/**
	 * Populates the list z as an arithmetic subtraction of elements from x and
	 * y; each list represents a big integer which is stored in LSB to MSB (i.e.
	 * LSB at head).
	 * 
	 * @param x
	 *            : List<Integer> : input list of integers to the base b;
	 *            representing a big integer
	 * @param y
	 *            : List<Integer> : input list of integers to the base b;
	 *            representing a big integer
	 * @param z
	 *            : List<Integer> : out list of integers after subtracting y
	 *            from x; represents a big integer
	 * @param b
	 *            : base b; the integers in the lists are based at b.
	 */
	public static void subtract(List<Long> x, List<Long> y, List<Long> z, long b) {

		Iterator<Long> xIterator = x.iterator();
		Iterator<Long> yIterator = y.iterator();

		Long xVal = Helper.next(xIterator);
		Long yVal = Helper.next(yIterator);

		int msbIndex = 0, index = 0;
		long borrow = 0;
		long difference = 0;

		// Invariant: msbIndex - holds the index of the nonzero msb, index - is
		// to capture the indexing, borrow - holds the borrow in subtraction
		// process, difference - difference of two integers. Loop iterates
		// through both lists, for each element - checks if there was any borrow
		// in earlier subtraction and decrements the xVal appropriately and
		// further subtracts the yVal(if not null) from xVal.
		while (xVal != null) {
			index++;
			difference = xVal;
			xVal = Helper.next(xIterator);
			if (borrow == 1) {
				difference--;
				borrow = 0;
			}
			if (yVal != null) {
				difference = difference - yVal;
				yVal = Helper.next(yIterator);
			}
			if (difference < 0) {
				difference = difference + b;
				borrow = 1;
			}
			z.add(new Long(difference));
			if (difference != 0)
				msbIndex = index;
		}

		// modify the list to avoid trailing zero's - optional as calculations
		// will not make much of difference in value but complexity might high
		// if the result is being accessed frequently for other calculations, in
		// such case we can remove trailing zeros using below method
		if (msbIndex != index) {
			removeTrailingZeros(z, msbIndex); // to avoid arbitrary behaviour if
												// this code is uncommented and
												// printOutList is also
			msbIndex = z.size();
		}

		// printOutList(z, msbIndex);
	}

	/**
	 * Removes the trailing zeros from the list. Irrespective of values, the
	 * method removes all values from msbIndex.
	 * 
	 * @param lst
	 *            : List<Integer> : input list which has to be processed
	 * @param msbIndex
	 *            : int : index from where values will be removed
	 */
	static void removeTrailingZeros(List<Long> lst, int msbIndex) {
		Iterator<Long> iterator = lst.iterator();
		while (iterator.hasNext()) {
			iterator.next();
			if (msbIndex > 0)
				msbIndex--;
			else
				iterator.remove();
		}
	}

	/**
	 * Adds y to x, x will hold the added result.
	 * @param x : List<Long> : list of numbers represented as List
	 * @param y : List<Long> : list of numbers represented as list
	 * @param base : long : numbers are in base 'base'
	 */
	static void addToX(List<Long> x, List<Long> y, long base) {
		if (y == null || y.size() == 0)
			return;
		if (x == null || x.size() == 0) {
			if (x == null)
				x = new ArrayList<Long>();
			x.addAll(y);
			return;
		}
		int xSize = x.size();
		int ySize = y.size();
		int i = 0;
		long sum, carry = 0;
		long xVal;
		while (i < xSize || i < ySize) {
			sum = carry;
			if (ySize > i) {
				sum = sum + y.get(i);
			}
			if (xSize > i) {
				xVal = x.get(i);
				sum = sum + xVal;
				carry = sum / base;
				x.set(i, new Long(sum % base));
			} else {
				carry = sum / base;
				x.add(new Long(sum % base));
			}
			i++;
		}

		if (carry != 0)
			x.add(new Long(carry));
	}

	/**
	 * Returns List which is a power of x to n.
	 * @param x : List<Long> : input list representing a long number
	 * @param n : long : power
	 * @param base : long : values are in base
	 * @return : List<Long> : result of power of x to n.
	 */
	static List<Long> power(List<Long> x, long n, long base) {
		if(x == null || x.size() == 0)
			throw new ArithmeticException("Input LongNumber does not have any number, cannot perform power on empty number");
		List<Long> result;
		if (n == 0) {
			result = new ArrayList<Long>();
			result.add(new Long(1));
			return result;
		} else if (n == 1)
			return x;
		else {
			List<Long> xSquare = null;
			xSquare = Product.product(x, x, base);
			result = power(xSquare, n / 2, base);
			if (n % 2 == 0)
				return result;
			else
				result = Product.product(result, x, base);
			return result;
		}

	}

	/**
	 * Returns true if x is larger in size compared to y. Note only size
	 * comparison.
	 * 
	 * @param x
	 *            : List<Long> : long number represented as list
	 * @param y
	 *            : List<Long> : long number represented as list
	 * @return : boolean : true if x is larger in size compared to y, false
	 *         otherwise
	 */
	static boolean isXGreater(List<Long> x, List<Long> y) {
		int xSize = x.size();
		int ySize = y.size();
		if (ySize > xSize)
			return false;
		return true;
	}

	/**
	 * Performs subtraction of l1 and l2 in base base
	 * @param l1 : LongNumber : input longNumber
	 * @param l2 : LongNumber : input long number
	 * @param base : long : numbers in base
	 * @return : LongNumber : returns longnumber which is a subtraction of l1 and l2
	 */
	static LongNumber subtract(LongNumber l1, LongNumber l2, long base){
		List<Long> x = l1.convertedNumber;
		boolean isXNeg = l1.isNegative;
		
		List<Long> y = l2.convertedNumber;
		boolean isYNeg = l2.isNegative;
		
		if(x == null || y == null)
			throw new ArithmeticException("Cannot perform subtraction with empty number. One of the operand has no number");
		List<Long> z = new ArrayList<Long>();
		boolean isZNeg = false;
		
		if((isXNeg || isYNeg) && !(isXNeg && isYNeg)){
			if(isXNeg)
				isZNeg = true;
			else
				isZNeg = false;
			add(x, y, z, base);
		} else{
			int compare = compareLists(x, y);
			if(compare == 1){
				isZNeg = isXNeg;
				subtract(x, y, z, base);
			} else if(compare == -1){
				isZNeg = !isYNeg;
				subtract(y, x, z, base);
			}
		}
		return new LongNumber(z, base, isZNeg);
	}
	
	/**
	 * Returns a long number which is a addition of l1 and l2
	 * @param l1 : LongNumber : input long number 1
	 * @param l2 : LongNumber : input long number 2
	 * @param base : long : numbers are represented in this base
	 * @return : LongNumber : returns addition of l1 and l2
	 */
	static LongNumber add(LongNumber l1, LongNumber l2, long base){
		List<Long> x = l1.convertedNumber;
		boolean isXNeg = l1.isNegative;
		
		List<Long> y = l2.convertedNumber;
		boolean isYNeg = l2.isNegative;
		
		if(x == null || y == null)
			throw new ArithmeticException("Cannot perform addition to empty number. one of the operand has empty number");
		
		boolean isZNeg = false;
		List<Long> z = new ArrayList<Long>();
		
		if((isXNeg || isYNeg) && !(isXNeg && isYNeg)){
			int compare = compareLists(x, y);
			if(compare > 0){
				isZNeg = isXNeg;
				subtract(x, y, z, base);
			}
			else if(compare < 0){
				isZNeg = isYNeg;
				subtract(y, x, z, base);
			} 
			else{
				z.add(new Long(0));
			}
		} else if(isXNeg && isYNeg){
			isZNeg = true;
			add(x, y, z, base);
		} else{
			isZNeg = false;
			add(x, y, z, base);
		}
		
		return new LongNumber(z, base, isZNeg);
	}
	
	/**
	 * Compares lists x and y, returns 0 if both the lists have same values, 1 if x is greater in value, -1 otherwise
	 * @param x : List<Long> : long number represented in the list form
	 * @param y : List<Long> : long number represented in the list form
	 * @return : int : 0 if lists are equal, 1 if x > y, -1 x < y
	 */
	static int compareLists(List<Long> x, List<Long> y){
		if(x == null || y == null || x.isEmpty() || y.isEmpty())
			return 4;
		int xSize = x.size();
		int ySize = y.size();
		if (ySize > xSize)
			return -1;
		else if(xSize > ySize)
			return 1;
		else{
			int i = xSize - 1;
			while(i >= 0){
				long xVal = x.get(i);
				long yVal = y.get(i);
				if(xVal > yVal)
					return 1;
				else if(xVal < yVal)
					return -1;
				i--;
			}
			return 0;
		}
	}
	
	/**
	 * Returns a LongNumber which is power of l1 to l2.
	 * @param l1 : LongNumber : input long number
	 * @param l2 : LongNumber : a positive long number, acts as a power
	 * @return : LongNumber : represents the result of l1 risen to l2
	 */
	static LongNumber power(LongNumber l1, LongNumber l2){
		if(l1 == null || l2 == null)
			throw new ArithmeticException("Operation cannot be performed, one of the arguments is null");
		long b1 = l1.base;
		long b2 = l1.base;
		if(b1 != b2)
			return null;
		
		List<Long> x1 = l1.convertedNumber;
		List<Long> x2 = l2.convertedNumber;
		if(x1 == null || x2 == null)
			throw new ArithmeticException("Operation cannot be performed, one of the number is null");
		long lsbOfN = x2.get(0);
		List<Long> result = power(x1, x2, b1);
		boolean isResNeg = false;
		if(l1.isNegative && !isEven(lsbOfN))
			isResNeg = true;
		return new LongNumber(result, b1, isResNeg);
	}
	
	/**
	 * Returns a List which is power of x to n.
	 * @param x : List<Long> : input long number represented in list form
	 * @param n : List<Long> : number acting as power represented in list form
	 * @param base : long : x and n are in this base
	 * @return : List<Long> : result of x risen to n.
	 */
	static List<Long> power(List<Long> x, List<Long> n, long base){
		if(n.size() == 1)
			return power(x, n.remove(0), base);
		else{
			Long shiftRemoved = shift(n);
			List<Long> xToTheS = power(x, n, base);
			List<Long> x1 = power(xToTheS, base, base);
			List<Long> x2 = power(x, shiftRemoved, base);
			return Product.product(x1, x2, base);
		}
	}
	
	/**
	 * Removes and Returns the LSB of the list
	 * @param li : List<Long> : input list of numbers
	 * @return : Long : number which is being discarded
	 */
	static Long shift(List<Long> li){
		Long val = li.remove(0);
		return val;
	}
	/**
	 * Returns true if the input number is even
	 * @param l1 : long : input number
	 * @return : boolean : return true if even, false otherwise
	 */
	static boolean isEven(long l1){
		return l1%2==0;
	}
	
	/**
	 * Performs division of l1 by l2.
	 * @param l1: LongNumber: input long number 1
	 * @param l2: LongNumber: input long number 2
	 * @return: LongNumber: division of l1 by l2
	 */
	static LongNumber divide(LongNumber l1, LongNumber l2) {
		if(l1 == null || l2 == null)
			return null;
		long b1 = l1.base;
		long b2 = l2.base;
		if (b1 != b2)
			return null;
		boolean isResNeg = false;
		if((l1.isNegative || l2.isNegative) && !(l1.isNegative && l2.isNegative))
			isResNeg = true;
		List<Long> resultList;
		resultList = Product
				.divide(l1.convertedNumber, l2.convertedNumber, b1);
		LongNumber result = new LongNumber(resultList, b1, isResNeg);
		return result;
	}
	/**
	 * Returns remainder of l1 divided by l2. effectively l1%l2.
	 * @param l1: LongNumber: input long number 1
	 * @param l2: LongNumber: input long number 2
	 * @return: LongNumber: mod(l1, l2)
	 */
	static LongNumber mod(LongNumber l1, LongNumber l2) {
		if(l1 == null || l2 == null)
			return null;
		long b1 = l1.base;
		long b2 = l2.base;
		if (b1 != b2)
			return null;
		boolean isResNeg = false;
		List<Long> resultList;
		resultList = Product
				.mod(l1.convertedNumber, l2.convertedNumber, b1);
		LongNumber result = new LongNumber(resultList, b1, isResNeg);
		return result;
	}
	/**
	 * Performs sqaureroot of l
	 * @param l: LongNumber: input long number 1
	 * @return: LongNumber: Square root of l
	 */
	static LongNumber squareRoot(LongNumber l) {
		
		long b = l.base;
		boolean isResNeg = false;
		List<Long> resultList;
		resultList = Product
				.squareRoot(l.convertedNumber,b);
		LongNumber result = new LongNumber(resultList, b, isResNeg);
		return result;
	}
	
	/**
	 * Performs Factorial of LongNumber
	 * @param l : LongNumber : long number
	 * @return : LongNumber : representing factorial of l
	 */
	static LongNumber factorial(LongNumber l){
		if(l.isNegative)
			return null;
		if(l.convertedNumber == null||l.convertedNumber.size() == 0)
			return null;
		if(l.convertedNumber.size() == 1 && l.convertedNumber.get(0) == 0){
			return new LongNumber("1");
		}
		List<Long> facList = factorial(l.convertedNumber, l.base);
		LongNumber factorial = new LongNumber(facList, l.base, false);
		return factorial;
	}
	
	/**
	 * Performs Factorial of val which is in base
	 * @param val : List<Long> : list representing number
	 * @param base : long : base
	 * @return : List<Long> : represents factorial
	 */
	static List<Long> factorial(List<Long> val, long base){
		List<Long> x   = new ArrayList<Long>();
		List<Long> one = new ArrayList<Long>();
		List<Long> y = new ArrayList<Long>();
		y.addAll(val);
		one.add(1l);
		while(compareLists(x,one) != 0)
		{
			x = new ArrayList<Long>();
			subtract(y, one, x,  base);
			y.clear();
			y.addAll(x);
			val = Product.product(val, x, base);
		}
		return val;
	}
	
	public static void main(String[] args) {
      LongNumber l1 = new LongNumber("5");
      LongNumber l2 = new LongNumber("1");

      LongNumber l3 = factorial(l1);
      l3.printList();
	}
}

/**
 * Class implementing product operation of Big Integer Arithmetic
 * 
 * @author Ravindhar Reddy Thallapureddy
 * Last modified on : 5/11/2016 2:38pm
 */
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Product {
	public static List<Long> add(List<Long> x, List<Long> y, long b) {
		Iterator<Long> xIterator = x.iterator();
		Iterator<Long> yIterator = y.iterator();
		List<Long> z = new ArrayList<Long>();

		Long xVal = Helper.next(xIterator);
		Long yVal = Helper.next(yIterator);

		long carry = 0;
		long sum = 0;

		// Invariant: carry is to hold any carry if generated by addition, sum
		// is to store the sum of elements; Iterates through both lists, adding
		// the elements (checking for carry), and appropriately updates z.
		while (xVal != null || yVal != null) {
			sum = carry;
			if (xVal != null) {
				sum = sum + xVal;
				xVal = Helper.next(xIterator);
			}
			if (yVal != null) {
				sum = sum + yVal;
				yVal = Helper.next(yIterator);
			}
			carry = sum / b;
			z.add(new Long(sum % b));
		}

		// if the addition has generated an element which is more than the size
		// of input lists e.g. 978 + 978 = 1956
		if (carry != 0)
			z.add(new Long(carry));
		return z;
	}

	public static void shiftAdd(List<Long> x, List<Long> y, int shift, long toBase) {
		int ySize = y.size();
		int xSize = x.size();
		int diff;
		if (shift >= ySize) {
			diff = shift - ySize;
			while (diff > 0) {
				y.add(new Long(0));
				diff--;
			}
			y.addAll(x);
		} else {
			int i;
			long sum, carry = 0;
			long xVal;
			for (i = 0; i < ySize - shift; i++) {
				sum = carry;
				long yVal = y.get(shift + i);
				if (i < xSize)
					xVal = x.get(i);
				else
					xVal = 0;
				sum = sum + xVal + yVal;
				carry = sum / toBase;
				y.set(shift + i, sum % toBase);
			}
			while (i < xSize) {
				sum = carry + x.get(i);
				y.add(new Long(sum % toBase));
				carry = sum / toBase;
				i++;
			}
			if (carry != 0)
				y.add(new Long(carry));
		}
	}

	/**
	 * Performs the subtraction of y from x
	 * @param x :List of numbers in base b representing x
	 * @param y :List of numbers in base b representing y
	 * @param b :Base of the numbers x and y
	 * @return: result of x-y as a list
	 */
	public static List<Long> subtract(List<Long> x, List<Long> y, long b) {
		List<Long> z = new ArrayList<Long>();
		Iterator<Long> xIterator = x.iterator();
		Iterator<Long> yIterator = y.iterator();

		Long xVal = Helper.next(xIterator);
		Long yVal = Helper.next(yIterator);

		int msbIndex = 0, index = 0;
		long borrow = 0;
		long difference = 0;

		// Invariant: msbIndex - holds the index of the nonzero msb, index - is
		// to capture the indexing, borrow - holds the borrow in subtraction
		// process, difference - difference of two integers. Loop iterates
		// through both lists, for each element - checks if there was any borrow
		// in earlier subtraction and decrements the xVal appropriately and
		// further subtracts the yVal(if not null) from xVal.
		while (xVal != null) {
			index++;
			difference = xVal;
			xVal = Helper.next(xIterator);
			if (borrow == 1) {
				difference--;
				borrow = 0;
			}
			if (yVal != null) {
				difference = difference - yVal;
				yVal = Helper.next(yIterator);
			}
			if (difference < 0) {
				difference = difference + b;
				borrow = 1;
			}
			z.add(new Long(difference));
			if (difference != 0)
				msbIndex = index;

		}

		// modify the list to avoid trailing zero's - optional as calculations
		// will not make much of difference in value but complexity might high
		// if the result is being accessed frequently for other calculations, in
		// such case we can remove trailing zeros using below method

		if (msbIndex != index) {
			removeTrailingZeros(z, msbIndex); // to avoid arbitrary behaviour if
												// this code is uncommented and
												// printOutList is also
			msbIndex = z.size();
		}

		return z;
		// printOutList(z, msbIndex);
	}

	/**
	 * Removes the trailing zeros from the list. Irrespective of values, the
	 * method removes all values from msbIndex.
	 * 
	 * @param lst
	 *            : List<Integer> : input list which has to be processed
	 * @param msbIndex
	 *            : int : index from where values will be removed
	 */
	static void removeTrailingZeros(List<Long> lst, int msbIndex) {
		Iterator<Long> iterator = lst.iterator();
		while (iterator.hasNext()) {
			iterator.next();
			if (msbIndex > 0)
				msbIndex--;
			else
				iterator.remove();
		}
	}
	/**
	 * Removes the trailing zeros in the list
	 * @param a: List: input
	 */
	public static void removeTrailingZeros(List<Long> a)
	{
     int count=0;		
	 for(long element: a)
	  if(element==0)
	    count++;
	 
	 if(count==a.size())
	 {
		  a.clear();
		  a.add(0l);
	 }
	 
	}
	/**
	 * Performs the multiplication of a and b
	 * @param a :List of numbers in base b representing a
	 * @param b :List of numbers in base b representing b
	 * @param base :Base of the numbers a and b
	 * @return : The product of a and b represented as a list
	 */

	public static List<Long> product(List<Long> a, List<Long> b, long base) {

		// If either of the lists is null, return null
		if(a==null || b==null)
			return null;
		//If either of the lists is empty, return null
		else if(a.isEmpty() || b.isEmpty())
			return null;
		
		int lengthOfB = b.size(), lengthOfA = a.size(),zerosAdded=0;
		List<Long> a1b1, a2b2, a1a2xb1b2, result, a1b1Pa2b2, second_term;
		boolean flag1=false,flag2=false; 
		List<Long> a1Pa2, b1Pb2;
		//its the base condition: if either of them contains  
		if (lengthOfA == 1 || lengthOfB == 1) {
			if (lengthOfA == 1)
				return multiply(a, b, 0, 0,lengthOfB - 1, base);
			return multiply(b, a, 0, 0,lengthOfA - 1, base);
		}
		// Adding zeros to List A if its length is odd  
		if(lengthOfA%2!=0){
			addLeadingZeros(a);
			zerosAdded++;
			lengthOfA++;
			flag1=true;
			if(a==b){
				lengthOfB++;
				zerosAdded++;
			}

		}
		// Adding zeros to List B if its length is odd
		if(lengthOfB%2!=0)
		{
			addLeadingZeros(b);
			zerosAdded++;
			lengthOfB++;
			flag2=true;

		}
		// If the length of A is more than that of B
		if (lengthOfA > lengthOfB) {
			a1b1 = getProduct(a, b, lengthOfB/2 ,lengthOfA-1, lengthOfB / 2,lengthOfB - 1, base);
			a2b2 = getProduct(a, b, 0, lengthOfB/2 - 1, 0, lengthOfB/2-1, base);
			a1Pa2 = getSum(a, a, 0, lengthOfB / 2-1, lengthOfB / 2, lengthOfA - 1, base);
			b1Pb2 = getSum(b, b, 0, lengthOfB / 2-1, lengthOfB / 2, lengthOfB - 1, base);
			a1a2xb1b2 = product(a1Pa2, b1Pb2, base);
			result = a2b2;
			a1b1Pa2b2 =  add(a1b1, a2b2,base);
			second_term =  subtract(a1a2xb1b2, a1b1Pa2b2,base);
			shiftAdd(second_term, result, lengthOfB / 2, base);
			shiftAdd(a1b1, result, lengthOfB, base);
			
		} 
		else  	// If the length of B is more than that of A
		{
			a1b1 = getProduct(a, b, lengthOfA / 2 ,lengthOfA-1,lengthOfA / 2, lengthOfB-1, base);
			a2b2 = getProduct(a, b, 0,lengthOfA / 2-1, 0,lengthOfA / 2-1, base);
			a1Pa2 = getSum(a, a, 0, lengthOfA / 2-1, lengthOfA / 2, lengthOfA - 1, base);
			b1Pb2 = getSum(b, b, 0, lengthOfA / 2-1,lengthOfA / 2, lengthOfB - 1, base);
			a1a2xb1b2 = product(a1Pa2, b1Pb2, base);
			result = a2b2;
			a1b1Pa2b2 = add(a1b1, a2b2,base);
			second_term = subtract(a1a2xb1b2, a1b1Pa2b2,base);
			shiftAdd(second_term, result, lengthOfA / 2, base);
			shiftAdd(a1b1, result, lengthOfA, base);

		}
		//Removing the leading zeros from the result
		//If zeros are added to individual lists
		if(zerosAdded>0)
			removeLeadingZeros(result,zerosAdded);
		//Removing the zeros added to the individual lists
		if(flag1)
			a.remove(0);
	
		if(flag2)
			b.remove(0);
        removeTrailingZeros(result);
		return result;
	}
	/**
	 * removes the n leading zero from the list
	 * @param a
	 * @param number
	 */
    public static void removeLeadingZeros(List<Long> a,int n)
    {
    	for(int j=1;j<=n;j++)
    		a.remove(0);
    }
    /**
	 * adds zero at the beginning of the list
	 * @param a
	 */
    public static void addLeadingZeros(List<Long> a)
    {
    	
    		a.add(0, 0l);;
    }
    /**
     * Performs the multiplication of two lists specified by the indices
     * @param a : List A
     * @param b :list B
     * @param begin_a : beginning index of the list A being considered for the multiplication
     * @param end_a : ending index of the list A being considered for the multiplication
     * @param begin_b : beginning of the list B being considered for the multiplication
     * @param end_b : ending of the list B being considered for the multiplication
     * @param base : base of numbers being multiplied
     * @return : returns the product of list A and list B
     */
    public static List<Long> getProduct(List<Long> a, List<Long> b, int begin_a, int end_a, int begin_b, int end_b,
			long base) {
		List<Long> a1b1, a2b2, a1a2mb1b2, result, a1b1pa2b2, second_term;
		List<Long> a1pa2, b1pb2;
		int zerosAdded=0;
		boolean flag1=false,flag2=false;
		//base condition: if either of the lists are of length 1
		if ((begin_a == end_a) || (begin_b == end_b)) {
			if (begin_a == end_a) {
				return multiply(a, b, begin_a, begin_b,end_b, base);
			} else {
				return multiply(b, a, begin_b, begin_a,end_a, base);
			}
		} 
		//Adding zeros to the list if its of odd length
		if((end_a-begin_a+1)%2!=0){
			a.add(begin_a, 0l);
			zerosAdded++;
			end_a++;
			flag1=true;
			
			/*
			 * Checking whether a and b are same
			 */
			if(a==b)
			{
				end_b++;
				zerosAdded++;
			}
		}
		if((end_b-begin_b+1)%2!=0){
			b.add(begin_b, 0l);
			zerosAdded++;
			end_b++;
			flag2=true;
			
		}
		//If the size of List A is more than that of List B
		if(end_a > end_b) {
			a1b1 = getProduct(a, b, (end_b+begin_b)/2+1,end_a,(end_b+begin_b)/2+1,end_b, base);
			a2b2 = getProduct(a, b, begin_a,(end_b+begin_b)/2, begin_b,(end_b+begin_b)/2, base);
			a1pa2 = getSum(a, a, begin_a,(end_b+begin_b)/2,(end_b+begin_b)/2+1, end_a, base);
			b1pb2 = getSum(b, b, begin_b, (end_b+begin_b)/2, (end_b+begin_b)/2+1, end_b, base);
			a1a2mb1b2 = product(a1pa2, b1pb2, base);
			result = a2b2;
			a1b1pa2b2 = add(a1b1, a2b2,base);
			second_term = subtract(a1a2mb1b2, a1b1pa2b2,base);
			shiftAdd(second_term,result, (end_b - begin_b+1) / 2,base);
			shiftAdd(a1b1,result, end_b - begin_b+1,base);
			
		}
		//If the size of List B is more than that of List A
		else
		{
		a1b1 = getProduct(a, b, (end_a+begin_a)/2+1,end_a, (end_a+begin_a)/2+1,end_b, base);
		a2b2 = getProduct(a, b, begin_a,(end_a+begin_a)/2, begin_b, (end_a+begin_a)/2, base);
		a1pa2 = getSum(a, a, begin_a, (end_a+begin_a)/2, (end_a+begin_a)/2+1, end_a, base);
		b1pb2 = getSum(b, b, begin_b, (end_a+begin_a)/2, (end_a+begin_a)/2+1, end_b, base);
		a1a2mb1b2 = product(a1pa2, b1pb2, base);
		result = a2b2;
		a1b1pa2b2 = add(a1b1, a2b2,base);
		second_term =  subtract(a1a2mb1b2, a1b1pa2b2,base);
		
		shiftAdd(second_term,result, (end_a - begin_a+1) / 2,base);
		shiftAdd(a1b1,result, end_a - begin_a+1,base);
		}
		if(zerosAdded>0)
			removeLeadingZeros(result,zerosAdded);
		if(flag1)
			a.remove(begin_a);
		if(flag2)
			b.remove(begin_b);
		
		return result;
	}

	/*
	public static ArrayList<Long> add(ArrayList<Long> a, ArrayList<Long> b) {
		return a;
	}

	public static ArrayList<Long> addafter(ArrayList<Long> a, ArrayList<Long> b, int n) {
		return a;
	}

	public static ArrayList<Long> subtract(ArrayList<Long> a, ArrayList<Long> b) {
		return a;
	}
*/
	public static List<Long> getSum(List<Long> a, List<Long> b, int begin_a, int end_a, int begin_b, int end_b,
			long base) {
		List<Long> result = new ArrayList<Long>();
		long carry = 0, sum = 0;
		int i, j;
		for (i = begin_a, j = begin_b; i <= end_a && j <= end_b; i++, j++) {
			sum = a.get(i) + b.get(j) + carry;
			carry = sum / base;
			result.add(sum % base);
		}
		while (i <= end_a) {
			sum = a.get(i) + carry;
			carry = sum / base;
			result.add(sum%base);
			i++;
		}
		while (j <= end_b) {
			sum = b.get(j) + carry;
			carry = sum / base;
			result.add(sum%base);
			j++;
		}
		if (carry != 0)
			result.add(carry);
		return result;
	}

	public static List<Long> multiply(List<Long> a, List<Long> b, int a_l, int b_l,int b_r, long base) {
		long carrier = 0, temp_res;
		int i;
		List<Long> res = new ArrayList<Long>();
		temp_res = a.get(a_l) * b.get(b_l);
		carrier = temp_res / base;
		res.add(temp_res % base);

		for (i = b_l + 1; i <= b_r; i++) {
			temp_res = b.get(i)*a.get(a_l)+ carrier;
			carrier = temp_res / base;
			res.add(temp_res % base);
		}
		if (carrier > 0)
			res.add(carrier);
		return res;
	}
	/**
	 * performs division operation a/b
	 * @param a: List of long numbers representing the dividend
	 * @param b: List of long numbers representing the Divisor
	 * @param base long: the base of numbers represented the given lists  
	 * @return List of Long numbers representing the quotient
	 * @throws ArithmeticException when the divisor is zero
	 */
	public static List<Long> divide(List<Long> a,List<Long> b,long base) throws ArithmeticException
	{
		List<Long> quotient=new ArrayList<Long>(),prevQuotient=new ArrayList<Long>();
		List<Long> lowerBound=new ArrayList<Long>();
		List<Long> upperBound=a;
		//Comparing dividend and divisor
		int status=compareLists(a,b);
		if(b.get(0)==1 && b.size()==1)
		{
			quotient=a;
			return quotient;
		}
		boolean flag=false;
		// If the given numbers are equal, return 1
		if(status==0)
		{
			quotient.add(1l);
			return quotient;
		}
		// If the divisor is greater than dividend, return 0 
		else if(status==-1)
		{
			quotient.add(0l);
			return quotient;
		}
		// If the divisor doesn't contain non-zero digits
		else
		{   
			for(long e:b)
				if(e!=0)
				{
					flag=true;
					break;
				}
			if(!flag)
				throw new ArithmeticException("Divisor can't be zero!");
			
				
		}
		lowerBound.add(1l);
		/*
		 *  Trying to find the quotient using binary search
		 */
		while(true)
		{
		
			quotient=getMidElement(lowerBound,upperBound,base);
			status=compareLists(a,product(quotient,b,base));
			// if quotient*A=B, we found the required result, so break
			if(status==0)
				break;
			// if quotient*A>B, update the upper bound
			if(status==-1)
				upperBound=quotient;
			// if quotient*A<B, update the lower bound
			else
				lowerBound=quotient;
			// if quotient is not changing, happens when upper=lower+1
			if(compareLists(quotient,prevQuotient)==0)
				break;
			prevQuotient=quotient;
			
		   		
		}
		return quotient;
	}
	/**
	 * performs comparison between two lists
	 * @param: x 
	 * @param: y
	 * @return: int 
	 *          0: If x=y
	 *          1: If x>y
	 *         -1: If y>x  
	 */
	static int compareLists(List<Long> x, List<Long> y){
		int xSize = x.size();
		int ySize = y.size();
		if (ySize > xSize)
			return -1;
		else if(xSize > ySize)
			return 1;
		else{
			int i = xSize - 1;
			while(i >= 0){
				long xVal = x.get(i);
				long yVal = y.get(i);
				if(xVal > yVal)
					return 1;
				else if(xVal < yVal)
					return -1;
				i--;
			}
			return 0;
		}
}
	/**
	 * returns the mid of numbers a, b represented in the lists A and B
	 * @param a : List A represents the first number
	 * @param b : List B represents the second number
	 * @return : mid of A and B as a  list
	 */
	public static List<Long> getMidElement(List<Long> a,List<Long> b,long base)
	{
		List<Long> result=add(a,b,base);
		result=divisionBy2(result);
		return result;
	}
	
	/**
	 * performs division by 2
	 * @param a: the input argument on which division is performed
	 * @return the dividend
	 */
	public static List<Long> divisionBy2(List<Long> a)
	{   long carry=0,sum;
		List<Long> result=new ArrayList<Long>();
		for(int i=a.size()-1;i>=0;i--)
		{
			sum=a.get(i)+carry*10;
			result.add(0, sum/2);
			carry=sum%2;
		}
		if(result.get(result.size()-1)==0)
			result.remove(result.size()-1);
		return result;
	}
	/**
	 * 
	 * @param a: List of long numbers representing A
	 * @param b: List of long numbers representing B
	 * @param base: the base being used in representing A and B
	 * @return: mod(A%B) as a list of long numbers
	 */
	public static List<Long> mod(List<Long> a,List<Long> b,long base)
	{
		List<Long> quotient=divide(a,b,base);
		List<Long> reminder=subtract(a,product(b,quotient,base),base);
		   if(reminder.isEmpty())
			   reminder.add(0l);
		return reminder;
	}
	/**
	 * 
	 * @param a: List of long numbers representing A
	 * @param base: the base being used in representing A
	 * @return: square root of A as a list of long numbers
	 */
	
	public static List<Long> squareRoot(List<Long> a,long base)
	{
		
		List<Long> SquareRoot=new ArrayList<Long>(),prevQuotient=new ArrayList<Long>();
		List<Long> lowerBound=new ArrayList<Long>();
		List<Long> upperBound=a;
		int status;
		lowerBound.add(0l);
		/*
		 *  Trying to find the quotient using binary search
		 */
		while(true)
		{
			SquareRoot=getMidElement(lowerBound,upperBound,base);
			status=compareLists(a,product(SquareRoot,SquareRoot,base));
			if(status == 4){
				SquareRoot.add(new Long(0));
				break;
			}
			// if quotient*A=B, we found the required result, so break
			if(status==0)
				break;
			// if quotient*A>B, update the upper bound
			if(status==-1)
				upperBound=SquareRoot;
			// if quotient*A<B, update the lower bound
			else
				lowerBound=SquareRoot;
			// if quotient is not changing, happens when upper=lower+1
			if(compareLists(SquareRoot,prevQuotient)==0)
				break;
			prevQuotient=SquareRoot;
			
		   		
		}
		return SquareRoot;
	}

	public static void main(String[] args) {
		ArrayList<Long> a = new ArrayList<Long>();
		ArrayList<Long> b = new ArrayList<Long>();
		/*a.add(0l);
		a.add(1l);
		a.add(2l);
		a.add(0l);
		a.add(7l);
		a.add(0l);
		a.add(7l);
		b.add(8l);
		b.add(8l);
		b.add(7l);
		b.add(8l);
		b.add(9l);
		b.add(8l);
		b.add(9l);
		a.add(6l);
		a.add(6l);
		a.add(3l);
		a.add(6l);
		a.add(4l);
		b.add(2l);
		b.add(1l);
		b.add(3l);
		b.add(9l);
		b.add(7l);*/
		//System.out.println((product( a,b, 10)));
		System.out.println(a);
		System.out.println(b);
		ArrayList<Long> c = new ArrayList<Long>();
		//c.add(1l);
		///c.add(0l);
		//c.add(3l);
		c.add(5l);
		c.add(4l);
		c.add(3l);
		c.add(2l);
		c.add(1l);
		a.add(2l);
		//a.add(0l);
		//a.add(0l);
		//a.add(0l);
		//a.add(0l);
		//a.add(1l);
		try{
		System.out.println( "Division"  +divide(c,a,10));
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
                
	}
}
